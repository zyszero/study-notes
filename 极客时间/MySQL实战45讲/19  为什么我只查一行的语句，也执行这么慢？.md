# 19 | 为什么我只查一行的语句，也执行这么慢？

前置条件：

```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i<=100000) do
    insert into t values(i,i);
    set i=i+1;
  end while;
end;;
delimiter ;

call idata();
```



## 第一类：查询时间长不返回

比如执行：

```mysql
mysql> select * from t where id=1;
```

首先通过`show processlist`命令，查看当前语句处于什么状态

### 等 MDL 锁 

执行`show processlist`现象：

![](.\images\19-waiting for table metadata lock.png)

复现过程：

| session A         | session B                     |
| ----------------- | ----------------------------- |
| lock table write; |                               |
|                   | select * from t where id = 1; |
|                   |                               |

解决办法：通过`select blocking_pid from sys_schema_table_lock_waits;` 找到`blocking_pid`，然后 `kill blocking_pid`

### 等 flush

现象：

![](.\images\19-waiting for flush.png)

复现过程：

| session A               | session B       | session C                    |
| ----------------------- | --------------- | ---------------------------- |
| select sleep(1) from t; |                 |                              |
|                         | flush tables t; |                              |
|                         |                 | select * from t where id =1; |

```mysql
flush tables t with read lock;

flush tables with read lock;
```

flush 会关闭指定的表。

waiting for flush 的原因：session A 在执行期间一直打开着表，所以session B 被阻塞，session C会被 flush 阻塞。

### 等行锁

现象：

![](.\images\19-等行锁.png)

复现步骤：

| session A                                 | session B                                         |
| ----------------------------------------- | ------------------------------------------------- |
| begin;   update set c = c+1 where id = 1; |                                                   |
|                                           | select * from t where id = 1 lock in  share mode; |

查询谁占据写锁的方法：

```mysql
select * from  sys.innodb_lock_waits where locked_table='`test`.`t`'\G;
```

然后执行 `KILL QUERY blocking_pid` 或 `KILL blocking_pid`

## 第二类：查询慢

`select * from t where id = 1;` 比 `select * from t whrere id  = 1 lock in share mode;`慢

复现步骤：

| session A                                      | session B                                       |
| ---------------------------------------------- | ----------------------------------------------- |
| start tansaction with consistent snapshot;     |                                                 |
|                                                | update t set c=c+1 where id = 1; // 执行100万次 |
| select * from t where id = 1;                  |                                                 |
| select * from where id = 1 lock in share mode; |                                                 |

原因：

![](.\images\19-查询慢.png)

session B 更新完100万次，生成100万个回滚日志（undo log），lock in share mode 是当前读，会直接读取1000001，速度很快，而`select * from t where id = 1`，是一致性读，需要从1000001开始，依次根据undo log，执行100万次，才能将结果 1 返回。

## 问题

```
begin;
select * from t where c=5 for update;
commit;
```

这个语句序列是怎么加锁的？加的锁又是什么时候释放呢？

