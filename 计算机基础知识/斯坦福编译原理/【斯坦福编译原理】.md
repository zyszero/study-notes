# 【斯坦福编译原理】

## 01 编译器与解释器简介

### 编译器与解释器

![](D:\study notes\计算机基础知识\斯坦福编译原理\images\1-编译器与执行器的区别.png)

Compile（编译器）：写好程序，通过编译器生成可执行代码；编译器无需结合数据，所以编译器是线下的（off-line）。

简单来说，编译的本质是用来生成可执行代码的预处理过程。

Interpreters（解释器）：写好程序，结合程序将数据传入解释器，程序就能立即执行。解释器是在线的（on-line），是程序运行的一部分。

>  执行和编译是两个阶段。执行属于线上的话。相对于解释器来讲。它需要结合数据进行执行。那此处编译器没有执行的步骤，所以属于线下。

解析器没有推广使用的原因：

- 执行效率低
- 自身占内存

### 编译器执行阶段

![](D:/study notes/计算机基础知识/斯坦福编译原理/images/1-编译器的五个执行阶段.png)

五个主要执行阶段：

1. 词法分析 
2. 语法分析
3. 语义分析：如类型和作用与规则
4. 优化：内存方面
5. 代码生成：转换成机器码或字节码或其他高级编程语言



## 02 编译器结构

### 编译阶段类比

- Lexical Analysis（词法分析） =》  1. 人类第一步尝试理解单词

  - 词法分析的目标就是将程序代码文本接照它的方式进行分词换句话说就是编译器说话时对词的区分
  - token（词法单元），if、then、else、空格、分隔符等等都是token

- Parsing（语法分析）  =》2. 紧接着理解句子的结构

  例子：

  ![](images/2-语法分析的例子.png)

  ![](images/2-语法分析例2.png)

  

- Semantic Analysis（语义分析） =》 3. 进一步尝试理解这句话的意思

  - too hard，编译器只能尽可能找出句子相互矛盾的地方

  - 例子：

    ![](images/2-语义歧义例子.png)

- Optimization（优化） =》 编辑，保持句子原有的语义，精简句子

  - 优化的目标

    - Run faster
    - Use less memory

  - 优化例子：

    ![](images/2-优化例子.png)

- Code Gen（生成代码） =>  翻译，将目标语言翻译为其他语言，比如：人工翻译可能会将英语翻译成法语一样，编译器会将高级程序转换为汇编代码

### 新旧编译器变化

![](images/2-新旧编译器阶段变化.png)



## 03 编程语言的性价比

### 为什么需要那么多的编程语言？

![](images/3-为什么需要那么多的编程语言？.png)

不同应用领域对于编程语言有着不同的需求。

### 为什么需要有新的编程语言出现？

![](images/3-为什么需要有新的编程语言？.png)

1. 广泛使用的编程语言发展会比较缓慢
2. 开发一门新的编程语言成本很低，容易学习
3. 填补空白的语言，即应对新应用领域的需求

### 如何判断一门编程语言是否优秀？

用的人越多，编程语言越好？

![](images/3-一门优秀的编程语言是什么样的？.png)



## 04 Cool 语言概述



## 05 Cool 语言概述 2



## 06 Cool 语言概述 3



## 07 词法分析 1



## 08 词法分析 2



## 09 词法分析 3 正则语言



## 10 词法分析 4 Formal Language



## 11 词法分析 5 词法规则



## 12 词法分析 6 Deducelt Demo



## 13 词法规范



## 14 有限自动机



## 15 从正则表达式到 NFA

### 构建词法分析器的流程图

![](D:\study notes\计算机基础知识\斯坦福编译原理\images\实现词法规范的流程.png)

实现词法规范：

1. 写出正则表达式集（词法规则）
2. 将正则表达式转化成 NFA（非确定性有限自动机）
3. NFA -> DFA（确定性有限自动机）
4. 使用一组 Lookup tables（查找表）并通过一些代码来对表进行遍历，以此实现确定性有限自动机

### 正则表达式 =》自动机 的实现例子

![](.\images\正则表达式-自动机1.png)

![](.\images\正则表达式-自动机2.png)

![](.\images\正则表达式-自动机3.png)

![](.\images\正则表达式-自动机4.png)

## 16 从 NFA 到 DFA

### ε-closure 的定义

![](.\images\ε-closure.png)

### NFA -> DFA

![](.\images\16-DFA定义.png)

- states：所有NFA可能的状态（除了空状态）
- start：在读到第一个输入的符号之前，它所处于实际状态集合就是开始状态 **ε-closure**
- final：集合X与NFA的最终状态集合相交，并且它不为空集
- 转换函数：**Y =  ε-clos(a(X))** 一个输入的字符只能对应一条执行线路，这条线路包含了一系列的多个状态 

**NFA => DFA 转换图：**

![](.\images\16-NFA-DFA的流程.png)

## 17 实现有限自动机



## 18 解析器介绍



## 19 上下文无关文法



## 20 推导



## 21 Ambiguity（歧义性）

### 歧义性出现的原因

![](images/21-歧义性出现的原因.png)

歧义性的例子：

![](images/21-歧义性的例子.png)

### 歧义性解决的办法
#### 重写语法
![](images/21-重写语法.png)

例子：

![](images/21-重写语法-例1.png)

  ![](images/21-重写语法-例2.png)

![](images/21-重写语法-例3.png)

#### 使用更自然的歧义语法
![](images/21-采用更自然的歧异语法.png)

例子1：

![](images/21-采用更自然的歧异语法-例子1.png)

例子2：

![](images/21-采用更自然的歧异语法-例子2.png)

## 22 错误处理

### 编译器如何处理错误？

#### 编译器的职责

编译器的两种不同职责与例子：

![](.\images\22-编译器两种不同职责与例子.png)

#### 错误处理器的要求

错误处理器的要求：

![](.\images\22-编译器错误处理的要求.png)

#### 错误处理的策略

错误处理的策略：

- Panic mode：紧急模式，最简单、最常用的错误恢复方法
- Error productions：错误产生式
- Automatic local or global correction：自动局部或全局校正

##### Panic mode

Panic mode 的基本思路是当一个错误被检测时，解析器会开始抛弃token直到在这门语言中我到一个作用明确的token为止，编译器会试着自己重启。然后从那个点继续工作。

![](.\images\22-Panic mode 处理错误的例子.png)

Panic mode 会丢弃第二个`+`，继续编译下去，直至遇到解析器可以识别的字符

##### Error Productions

![](.\images\22-Error Productions与例子.png)**Error Productions：**它将程序员常犯的已知错误指定为语法中的替代产生式（编译器设计者可能知道代码中可能出现的一些常见错误。也可以使用增强语法作为在遇到这些错误时生成错误结构的产品）

##### Automatic local or global correction

![](.\images\22-Automatic local or global correction.png)

![](.\images\22-过去与现在的编译需求对比.png)

从图中可以看出，不使用**Automatic local or global correction**的原因。

## 23 抽象语法树

抽象语法树（**AST**，**Abstract Syntax Tree**）是编译器中的核心数据结构，它优于以往讲的解析树。

![](images/23-AST.png)

AST 的语法：

![](images/23-AST grammar-1.png)

- 定义语法：E -> int | (E) | E + E
- 给出字符串：5+（2+3）
- 进行词法分析：int5 '+' '(' int2 '+' int3 ')'
- 然后传入解析器得到一颗解析树

![](images/23-AST grammar-parse tree.png)

AST结构与好处：

![](images/23-AST的好处与作用.png)

**AST **将具体的语法进行了抽象，取消了具体语法的细节，只保留了足够的信息，能够很好地表示程序要做的事，并进行编译。

## 24 递归下降解析

### 递归下降解析定义

递归下降解析算法是一种自上而下，从左到右的解析算法。

![](images/24-递归下降解析算法.png)


### 解析例子

![](images/24-递归下降解析算法的例子.png)

从根节点开始，自上而下的进行解析，从左到右一个一个去尝试匹配表达式

![](images/24-递归下降解析尝试匹配-失败-回溯.png)

![](images/24-递归下降解析尝试匹配-匹配-重复.png)

![](images/24-递归下降解析尝试匹配-最终匹配-接受.png)

## 25 递归下降解析算法

### 前置知识点

![](D:\study notes\计算机基础知识\斯坦福编译原理\images\25-前置知识点.png)

### 定义一个用来匹配输入中所给定token的函数


1. ![](D:\study notes\计算机基础知识\斯坦福编译原理\images\25-匹配输入token的函数.png)

2. 每个产生式都有一个对应函数，会检查这个产生式是否能和这个输入匹配上

3. 将关于这个特定非终结元素的所有产生式组合在一起，然后检查这些产生式中是否有任何一个能和输入进行匹配

   ![](D:\study notes\计算机基础知识\斯坦福编译原理\images\25-匹配输入token的函数-2.png)

### 方法定义

![](images/25-方法定义-1.png)

![](images/25-方法定义-2.png)

### 解析器的启动流程

![](images/25-解析器的启动流程.png)

- 初始化一个 next 指针，指向输入的第一个token
- 调用 E()

### 递归下降解析的例子

![](images/25-递归下降解析的完整例子.png)

从（int）开始解析，步骤如上图




## 26 递归下降的局限性

### 局限性例子

![](images/26-递归下降解析算法的局限性.png)

上述介绍的递归下降算法是具有局限性的，例如解析复杂度的式子：`int * int`，E() -> T() -> T1() -> trem(INT)，会发现T1返回的是`true`，由于T1() return true，那么T() 也 return true，最后E()解析完毕，返回true，但事实上指针才往前移动至`int`后面，这时候还未遇到终结元素，程序就执行完了，导致解析被拒接；局限性在于这个结构和算法中，没有办法去回滚之前的决定并尝试一个不同的产生式。

## 27 左递归(Left Recursion)

### 左递归

![](images/27-左递归.png)

左递归语法是指具有非终结符的住何语法，如果是从非终结符开始，你就要做一系列非空序列重写（译者注：就是循环调用）

递归下降解析是没办法适用于任何左递归语法，因为递归下降解析想要做的是先生成输入中的第一部分，然后从左到右进行工作，但左递归语法却是按照从右到左的顺序构建字符串的。

例如：

```mathematica
S -> Sα|β  =》 S->Sα->Sαα-> Sαα...αα -> βαα..α
```

我们可以用右递归语法来替换左递归语法，以此解决这个问题。

首先添加在语法上添加符号，例如：

```mathematica
S-> βS'
S'-> αS'|ε
推导公式：
S->βS'->βαS'->βααS'->βα...αS'->βαα...α
```

右递归替代左递归的例子：

![](images/27-常见的左递归问题与右递归.png)

![](images/27 - 右递归重写左递归.png)



### 非直接左递归

![](images/27-非直接左递归.png)

### 小结

![](images/27-小结.png)



## 28 预测解析(Predictive Parsing)

### 预测解析

![](images/28-预测解析与LL(k).png)

预测解析**(Predictive Parsing)**，也是一个自上而下的解析器，始终能够正确地猜出该使用哪个产生式来得到一个正确的解析。

预测解析的特点：

- 会使用向前看的方式来尝试指出该使用哪个产生式
- 没有回滚操作

预测解析接受一种**LL(k)**的语法

- 第一个 **L** 代表 left to right 从左到右扫描
- 第二个 **L** 代表使用最左推导构建一个解析树
- **k** 代表有k个需要向前看的token（理论上 k 可以是任意数，实战上 k 只会为 1）

### 递归下降解析器与LL(1)解析器的区别

![](images/28-递归下降解析器与LL(1)解析器的区别.png)

递归下降解析器

- 在递归下降解析的每一步中，可能会有很多可供选择的产生式来选行使用
- 回滚操作用来撤销错误的选择

LL(1)解析器

- 每一步只会有一个可供选择的产生式来进行使用

### 提左公因子

提左公因子背景：

 ![](images/28-提左公因子的背景.png)



提取左公因子背后的思路就是消除一个非终结符的多个产生式的公共前缀。

提取左公因子的推导例子：

![](images/28-提左公因子的例子.png)

提取左公因子语法：

![](images/28-提取最左公因式的语法.png)

### LL(1)解析表

LL(1)解析表定义：

![](images/28-LL(1)解析表.png)

空单元格表示错误的解析。

LL(1)解析表的例子：

![](images/28-LL(1)解析表的例子.png)

解析表的步骤：

![](images/28-LL(1)解析表的步骤.png)

### LL(1)解析算法

![](images/28-解析表结合栈的使用.png)

LL(1)解析算法：栈+解析表来实现

![](images/28-LL(1)的解析算法.png)

使用解析表进行解析的例子：

![](images/28-使用解析表进行解析的例子.png)



## 29 First集

![](images/29-First(A) and Follow(A).png)

> 在构建解析表过程中有2个集合是需要被关注的一个是first 集，一个是follow集
> T【A,t】=a 解析表中表示存在一个非终结符号A和终结符号可以解析成a，这可以理解为生产式 A->a 中，如何输入符号是终结符号t的话，是可以被该生产式match的，而且必须是在首字符match，也就是First set；故此时t∈First(A)
> 在生产式 a->*tß中，当a在生产式右边第一个位置可以解析成 t 的话，则t 是first(a) 中的一个元素，a也许可以转为其他符号
> 如果存在这样生产式，右侧有个一个终结符号t是紧随着非终结符号A的，当且A->£ 即A解析成空字符串时(A无法直接解析成t)，该生产式可以解析成t ，则t是Follow(A) 即 t ∈ Follow(A)
>
> java-深圳-czr

### First Sets的定义

First Set 的定义：`First(X) ={t|X->*ta}U{£|X->£}`

实际上，这里的X是一个字符串。这个X可能是一个终结符也可能是一个非终结符。或者它还可能是一个语法符号字符串。

### First Sets的计算方式

![](images/29-First Set的定义以及计算方式.png)

算法描述：

1. First(t) = {t}，对于所有终结符，它们的First集有该终结符的元素组成
2. £∈First(X) 
   - **if X->£**，即X能解析出£
   - **if X->A1A2…An and £∈First(Ai) for 1<=i<=n**，即X能解析出A1...An，A1...An能解析出£，注意：A1...An都是非终结符。
   - **First(a)⊆First(X) if X->A1...Ana and £∈First(Ai); for 1<=i<=n**

### 计算First Sets的例子

![](images/29-First Set计算练习例子.png)

**注意：终结符的First Sets 就是它本身**

```mathematica
First(E) = First(T)的推导过程：
由First Set的定义，可得 First(T) ⊆ First(E)
First(T)={(,int}，因为T无法推导成£，即First(T)至少会提供一个终结符，所以X始终无法为First(E)提供终结符，即First(E) = First(T)
```

## 30 Follow集

### Follow Sets 定义

Follow Sets 定义：`Follow(X) = {t | S -> *βXtδ}`

实际上，Follow(X)完全不取决于符号X可以产生什么，而取决于符号X可以出现的位置，即该符号在语法中的使用位置。

比如 在`Follow(X) = {t | S -> *βXtδ}`中，t是Follow(X)中的元素。

客观事实：

- X->AB => First(B) ⊆ Follow(A)，即有这样一个基本规则。即当你有两个相邻符号的时候第二个符号的First集中的元素是第一个符号的Follow集中的元素。

  ```mathematica
  1. X->AB->*Atβ
  2. First(B) = {t}
  3. Follow(A) = {t}
  4. First(B) ⊆ Follow(A) 
  ```
  - 如果 B ->*ε，则 Follow(X) ⊆ Follow(A)

    ```mathematica
    假设：
    S->Xt->ABt => Follow(X) ⊆ Follow(B)
    如果 B ->*ε，即S->Xt->ABt->At =>  Follow(X) ⊆ Follow(A)
    ```

- 如果S是开始符号，则 $ ∈ Follow(S)

### Follow Sets 算法概要

![](images/30-Follow Sets 定义和规则.png)

- Follow Sets 不关心`ε`

### Follow Sets 例子

![](images/30-Follow Sets 例子.png)